geom_smooth(method="lm", formula=y_obs_2~poly(x, 2))
datos_simulados %>%
ggplot(aes(x = x, y = y_obs_1)) +
geom_smooth(method = "lm", formula = y~x, se = FALSE, color="lightblue") +
geom_point()+
geom_point(aes(y=y_obs_2), col='red')+
geom_smooth(method="lm", se= FALSE ,formula=y_obs_2~poly(x, 2))
datos_simulados %>%
ggplot(aes(x = x, y = y_obs_1)) +
geom_smooth(method = "lm", formula = y~x, se = FALSE, color="lightblue") +
geom_point()+
geom_point(aes(y=y_obs_2), col='red')+
geom_smooth(method="lm", se= FALSE ,formula=y_obs_2~poly(x, 2))+
ylab("Y")
bo = 2
b1_1 = 3
b1_2 = 0.5
x <- seq(1,10)
# Estructura para el valor esperado de y dado x ()
# Esta estructura admitir√≠a otras formas funcionales
# El valor esperado es deterministico.
e_y_x_1 <- bo + b1_1 * x
e_y_x_2 <- bo + b1_1 * x + b1_2 * x^2
# Valor observado o valor real, es aleatorio.
# Todo modelo teorico se compone de dos t√©rminos:
# 1) El valor E(y|x)= e_y_x (valor esperado de y dado x)
# 2) El componente aleatorio tambi√©n llamado error.
y_obs_1 <- e_y_x_1 + rnorm(10, 0, 4)
y_obs_2 <- e_y_x_2 + rnorm(10, 0, 4)
datos_simulados <- data.frame(
x = x,
x_2 = x^2,
e_y_x_1 = e_y_x_1,
e_y_x_2 = e_y_x_2,
y_obs_1 = y_obs_1,
y_obs_2 = y_obs_2,
y_pred_1 = predict(lm(y_obs_1 ~ x)),
y_pred_2 = predict(lm(y_obs_2 ~ x+ x^2)))
datos_simulados %>%
ggplot(aes(x = x, y = y_obs_1)) +
geom_smooth(method = "lm", formula = y~x, se = FALSE, color="lightblue") +
geom_point()+
geom_point(aes(y=y_obs_2), col='red')+
geom_smooth(method="lm", se= FALSE ,formula=y_obs_2~poly(x, 2))+
ylab("Y")
n <- 1000
vector_x <- c(1: n )
sigma <- 4
alpha <- 0.7
E_y_x_3 = bo + alpha * (x + x^2)
y_obs_3 = E_y_x_3 + rnorm(10, 0, 4)
x_auxiliar = x + x^2
datos_simulados_2 <- data.frame(
x = x,
x_2 = x^2,
x_auxiliar = x_auxiliar,
E_y_x_3 = E_y_x_3,
y_obs_3 =  y_obs_3,
y_pred_3_1 = predict(lm(y_obs_3 ~ x + x^2 )),
y_pred_3_2 = predict(lm(y_obs_3 ~ x_auxiliar )))
modelo1 = lm(y_obs_3 ~ x + x^2 )
modelo2 = lm(y_obs_3 ~ x_auxiliar )
print(modelo1)
print(modelo2)
alpha <- 0.7
E_y_x_3 = bo + alpha * (x + x^2)
y_obs_3 = E_y_x_3 + rnorm(10, 0, 4)
x_auxiliar = x + x^2
datos_simulados_2 <- data.frame(
x = x,
x_2 = x^2,
x_auxiliar = x_auxiliar,
E_y_x_3 = E_y_x_3,
y_obs_3 =  y_obs_3,
y_pred_3_1 = predict(lm(y_obs_3 ~ poly(x, 2))),
y_pred_3_2 = predict(lm(y_obs_3 ~ x_auxiliar )))
modelo1 = lm(y_obs_3 ~ poly(x, 2) )
modelo2 = lm(y_obs_3 ~ x_auxiliar )
print(modelo1)
print(modelo2)
datos_simulados_2 %>%
ggplot()+
geom_point(aes(x = x , y = y_obs_3), col = 'green')+
geom_point(aes(x = x, y = y_pred_3_1, col = 'blue'))+
geom_point(aes(x = x, y = y_pred_3_2, col = 'red'))
datos_simulados_2 %>%
ggplot()+
geom_point(aes(x = x , y = y_obs_3), col = 'green')+
geom_point(aes(x = x, y = y_pred_3_1, col = 'blue'))+
geom_point(aes(x = x, y = y_pred_3_2, col = 'red'))
datos_simulados_2 %>%
ggplot()+
geom_point(aes(x = x , y = y_obs_3), col = 'green')+
geom_point(aes(x = x, y = y_pred_3_1), col = 'blue')+
geom_point(aes(x = x, y = y_pred_3_2), col = 'red')
datos_simulados_2 %>%
ggplot(aes(x = x , y = y_obs_3))+
geom_point(col = 'green')+
geom_point(aes(y = y_pred_3_1), col = 'blue')+
geom_point(aes(y = y_pred_3_2), col = 'red')
datos_simulados_2 %>%
ggplot(aes(x = x , y = y_obs_3))+
geom_point(col = 'green')+
geom_point(aes(y = y_pred_3_1), col = 'blue')+
geom_point(aes(y = y_pred_3_2), col = 'red')
33.72 + 73.35*5 + 21.14*25
summary(modelo1)
summary(modelo2)
summary(lm(y_obs_3 ~ poly(x, 2, raw=TRUE)))
summary(modelo1)
summary(modelo2)
summary(lm(y_obs_3 ~ poly(x, 2, raw=TRUE)))
3.25280 + 0.19135 * 5 + 0.74109 * 25
knitr::opts_chunk$set(
warning = FALSE,
echo = TRUE,
message = FALSE
)
# Librer√≠as
library(tidyverse)
library(janitor)
library(openxlsx)
library(flextable)
library(viridis)
library(scales)
library(DT)
library(lubridate)
library(gridExtra)
# Cargue y limpieza de datos.
dolar <- read.csv2("DATASETS/Tasa_de_Cambio_Representativa_del__Mercado_-Historico.csv") %>%
clean_names()
hass <- read.xlsx("DATASETS/Hass_Precios_Historicos.xlsx") %>% clean_names()
# Funciones
## Funci√≥n para crear flextable
ftable <- function(x) {
x %>%
flextable() %>%
theme_vanilla() %>%
color(part = "footer", color = "#666666") %>%
color( part = "header", color = "#FFFFFF") %>%
bg( part = "header", bg = "#2c7fb8") %>%
fontsize(size = 11) %>%
font(fontname = 'Calibri') %>%
# Ajustes de ancho y tipo de alineaci√≥n de las columnas
set_table_properties(layout = "autofit") %>%
# width(j=1, width = 3) %>%
align(i = NULL, j = c(2:ncol(x)), align = "right", part = "all")
}
dolar %>%
head(5)
dolar %>%
head(5) %>%
ftable()
# Vamos a sacar un valor promedio de cada variable por mes
#Para el dolar vamos a tomar el campo vigenciadesde
dolar <- dolar %>%
mutate(fecha = as.Date(vigenciadesde, format = "%d/%m/%y")) %>%
mutate(mes = month(fecha), anio = year(fecha)) %>%
mutate(valor = as.double(str_replace(valor,",",""))) %>%
group_by(anio,mes) %>%
summarise(promedio_dolar = mean(valor), .groups = "drop")
dolar %>%
datatable()
hass %>%
head(5) %>%
ftable()
# üñáÔ∏è Se genera el vector de meses para usarlo m√°s abajo con la funci√≥n match.
meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")
hass <- hass %>%
# Otra forma de sacar el anio.
#mutate(anio = substring(fecha,nchar(fecha)-4,nchar(fecha))) %>%
#mutate(espacio = grepl(", ",fecha))
mutate(mes = sapply(strsplit(fecha, " "), "[", 2),
anio = sapply(strsplit(fecha, " "), "[", 5)) %>%
mutate(anio = as.double(anio)) %>%
# üñá Se utiliza la funci√≥n match con el vector meses.
mutate(mes = match(mes,meses)) %>%
group_by(anio,mes) %>%
summarise(promedio_aguacate_kg = mean(precio_kg), .groups = "drop")
hass %>% datatable()
hass_dolar <- dolar %>%
right_join(hass, by = c("mes","anio"))
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+ theme_light()
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+
geom_hline(yintercept = mean(hass_dolar$promedio_aguacate_kg))+
theme_light()
# En esta secci√≥n el estudiante desarrollar√° los c√°lculos.
# üí° Recordemos que la varianza de los residuales respecto del modelo ingenuo, es la misma varianza de la variable a predecir.
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+
geom_hline(yintercept = mean(hass_dolar$promedio_aguacate_kg))+
geom_segment(aes(xend=promedio_dolar, yend=mean(promedio_aguacate_kg)),
col='red', lty='dashed')+
theme_light()
# lm(formula, data, subset, weights, na.action,
#    method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE,
#    singular.ok = TRUE, contrasts = NULL, offset, ...)
mod1 <- hass_dolar %>% lm(promedio_aguacate_kg ~ promedio_dolar,.)
summary(mod1)
# Generando el modelo con R Base ser√≠a as√≠:
# mod1 <- lm(promedio_aguacate_kg ~ promedio_dolar, hass_dolar)
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+ theme_light()+
geom_smooth(method='lm', formula=y~x, se=FALSE, col='dodgerblue1')
mod1$coefficients
mod1$fitted.values %>%
head(20)
mod1$residuals %>%
head(20)
# Los valores ajustados y los residuales tambi√©n se pueden recuperar usando las funciones fitted( ) y residuals( ). Consulte la ayuda de estas funciones para conocer otros detalles.
# En esta secci√≥n el estudiante desarrollar√° los c√°lculos.
# En esta secci√≥n el estudiante desarrollar√° los c√°lculos.
#hass_dolar$predicciones <- predict(mod1)
hass_dolar <- hass_dolar %>%
mutate(predicciones = predict(mod1))
hass_dolar %>%
ggplot(aes(x = promedio_dolar, y = promedio_aguacate_kg)) +
geom_smooth(method = "lm", se = FALSE, color="lightblue") +
geom_segment(aes(xend=promedio_dolar, yend=predicciones),
col='red', lty='dashed') +
geom_point() +
geom_point(aes(y=predicciones), col='red') +
theme_light()
#Con R Base
# ggplot(datos, aes(x=Edad, y=Resistencia)) +
#   geom_smooth(method="lm", se=FALSE, color="lightgrey") +
#   geom_segment(aes(xend=Edad, yend=predicciones), col='red', lty='dashed') +
#   geom_point() +
#   geom_point(aes(y=predicciones), col='red') +
#   theme_light()
bo = 2
b1_1 = 3
b1_2 = 0.5
x <- seq(1,10)
# Estructura para el valor esperado de y dado x ()
# Esta estructura admitir√≠a otras formas funcionales
# El valor esperado es deterministico.
E_y_x_1 <- bo + b1_1 * x
E_y_x_2 <- bo + b1_1 * x + b1_2 * x^2
# el valor observado o valor real, es aleatorio.
y_obs_1 <- E_y_x_1 + rnorm(10, 0, 4)
y_obs_2 <- E_y_x_2 + rnorm(10, 0, 4)
datos_simulados <- data.frame(
x = x,
x_2 = x^2,
E_y_x_1 = E_y_x_1,
E_y_x_2 = E_y_x_2,
y_obs_1 = y_obs_1,
y_obs_2 = y_obs_2,
y_pred_1 = predict(lm(y_obs_1 ~ x)),
y_pred_2 = predict(lm(y_obs_2 ~ x+ x^2)))
datos_simulados %>%
ggplot(aes(x = x, y = y_obs_1)) +
geom_smooth(method = "lm", formula = y~x, se = FALSE, color="lightblue") +
geom_point()+
geom_point(aes(y=y_obs_2), col='red')+
geom_smooth(method="lm", se= FALSE ,formula=y_obs_2~poly(x, 2))+
ylab("Y")
alpha <- 0.7
E_y_x_3 = bo + alpha * (x + x^2)
x_auxiliar = x + x^2
datos_simulados_2 <- data.frame(
x = x,
x_2 = x^2,
x_auxiliar = x_auxiliar,
E_y_x_3 = E_y_x_3,
y_obs_3 =  y_obs_3,
y_pred_3_1 = predict(lm(y_obs_3 ~ poly(x, 2))),
y_pred_3_2 = predict(lm(y_obs_3 ~ x_auxiliar )))
modelo1 <-  lm(y_obs_3 ~ poly(x, 2, raw = TRUE))
modelo2 <-  lm(y_obs_3 ~ x_auxiliar )
print(modelo1)
print(modelo2)
summary(modelo1)
summary(modelo2)
summary(lm(y_obs_3 ~ poly(x, 2, raw=TRUE)))
summary(lm(y_obs_3 ~ poly(x, 2, raw=TRUE)))
summary(modelo1)
summary(modelo2)
summary(lm(y_obs_3 ~ poly(x, 2, raw=TRUE)))
summary(modelo1)
datos_simulados %>%
ggplot(aes(x = x, y = y_obs_1)) +
geom_smooth(method = "lm", formula = y~x, se = FALSE, color="lightblue") +
geom_point(col = "green")+
geom_point(aes(y=y_obs_2), col='red')+
geom_smooth(method="lm", se= FALSE ,formula=y_obs_2~poly(x, 2),color = "blue")+
ylab("Y")
seed(777)
modelo1a <-  lm(y_obs_3 ~ poly(x, 2))
modelo1a$coefficients
modelo1a$coefficients[1]
modelo1b <-  lm(y_obs_3 ~ poly(x, 2), raw = TRUE)
modelo1b$coefficients[1]
modelo1b$coefficients[2]
modelo1b$coefficients[3]
modelo1b$coefficients[2]
modelo1a <-  lm(y_obs_3 ~ poly(x, 2))
modelo1b <-  lm(y_obs_3 ~ poly(x, 2), raw = TRUE)
summary(lm(y_obs_3 ~ poly(x, 2), raw = TRUE))
summary(lm(y_obs_3 ~ poly(x, 2)))
summary(lm(y_obs_3 ~ poly(x, 2), raw = TRUE))
modelo1b <-  lm(y_obs_3 ~ poly(x, 2, raw = TRUE))
summary(lm(y_obs_3 ~ poly(x, 2, raw = TRUE)))
u1 = 1/sqrt(2)
u2 = sqrt(3/2) * (5-1)
u3 = sqrt(5/2) * ((3/2)*(5^2) - 3*5 + 1)
#E_y_5 = coef1 * u1 + coef2*u2 + coef3*u3
E_y_5 = modelo1a$coefficients[1] * u1 + modelo1a$coefficients[2]*u2 + modelo1a$coefficients[3]*u3
E_y_5
modelo1a$coefficients[1] * u1
modelo1a$coefficients[1]
knitr::opts_chunk$set(
warning = FALSE,
echo = TRUE,
message = FALSE
)
# Librer√≠as
library(tidyverse)
library(janitor)
library(openxlsx)
library(flextable)
library(viridis)
library(scales)
library(DT)
library(lubridate)
library(gridExtra)
# Cargue y limpieza de datos.
dolar <- read.csv2("DATASETS/Tasa_de_Cambio_Representativa_del__Mercado_-Historico.csv") %>%
clean_names()
hass <- read.xlsx("DATASETS/Hass_Precios_Historicos.xlsx") %>% clean_names()
# Funciones
## Funci√≥n para crear flextable
ftable <- function(x) {
x %>%
flextable() %>%
theme_vanilla() %>%
color(part = "footer", color = "#666666") %>%
color( part = "header", color = "#FFFFFF") %>%
bg( part = "header", bg = "#2c7fb8") %>%
fontsize(size = 11) %>%
font(fontname = 'Calibri') %>%
# Ajustes de ancho y tipo de alineaci√≥n de las columnas
set_table_properties(layout = "autofit") %>%
# width(j=1, width = 3) %>%
align(i = NULL, j = c(2:ncol(x)), align = "right", part = "all")
}
dolar %>%
head(5)
dolar %>%
head(5) %>%
ftable()
# Vamos a sacar un valor promedio de cada variable por mes
#Para el dolar vamos a tomar el campo vigenciadesde
dolar <- dolar %>%
mutate(fecha = as.Date(vigenciadesde, format = "%d/%m/%y")) %>%
mutate(mes = month(fecha), anio = year(fecha)) %>%
mutate(valor = as.double(str_replace(valor,",",""))) %>%
group_by(anio,mes) %>%
summarise(promedio_dolar = mean(valor), .groups = "drop")
dolar %>%
datatable()
hass %>%
head(5) %>%
ftable()
# üñáÔ∏è Se genera el vector de meses para usarlo m√°s abajo con la funci√≥n match.
meses <- c("Enero", "Febrero", "Marzo", "Abril", "Mayo", "Junio", "Julio", "Agosto", "Septiembre", "Octubre", "Noviembre", "Diciembre")
hass <- hass %>%
# Otra forma de sacar el anio.
#mutate(anio = substring(fecha,nchar(fecha)-4,nchar(fecha))) %>%
#mutate(espacio = grepl(", ",fecha))
mutate(mes = sapply(strsplit(fecha, " "), "[", 2),
anio = sapply(strsplit(fecha, " "), "[", 5)) %>%
mutate(anio = as.double(anio)) %>%
# üñá Se utiliza la funci√≥n match con el vector meses.
mutate(mes = match(mes,meses)) %>%
group_by(anio,mes) %>%
summarise(promedio_aguacate_kg = mean(precio_kg), .groups = "drop")
hass %>% datatable()
hass_dolar <- dolar %>%
right_join(hass, by = c("mes","anio"))
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+ theme_light()
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+
geom_hline(yintercept = mean(hass_dolar$promedio_aguacate_kg))+
theme_light()
# En esta secci√≥n el estudiante desarrollar√° los c√°lculos.
# üí° Recordemos que la varianza de los residuales respecto del modelo ingenuo, es la misma varianza de la variable a predecir.
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+
geom_hline(yintercept = mean(hass_dolar$promedio_aguacate_kg))+
geom_segment(aes(xend=promedio_dolar, yend=mean(promedio_aguacate_kg)),
col='red', lty='dashed')+
theme_light()
# lm(formula, data, subset, weights, na.action,
#    method = "qr", model = TRUE, x = FALSE, y = FALSE, qr = TRUE,
#    singular.ok = TRUE, contrasts = NULL, offset, ...)
mod1 <- hass_dolar %>% lm(promedio_aguacate_kg ~ promedio_dolar,.)
summary(mod1)
# Generando el modelo con R Base ser√≠a as√≠:
# mod1 <- lm(promedio_aguacate_kg ~ promedio_dolar, hass_dolar)
hass_dolar %>%
ggplot(aes(x= promedio_dolar, y= promedio_aguacate_kg )) +
geom_point()+ theme_light()+
geom_smooth(method='lm', formula=y~x, se=FALSE, col='dodgerblue1')
mod1$coefficients
mod1$fitted.values %>%
head(20)
mod1$residuals %>%
head(20)
# Los valores ajustados y los residuales tambi√©n se pueden recuperar usando las funciones fitted( ) y residuals( ). Consulte la ayuda de estas funciones para conocer otros detalles.
# En esta secci√≥n el estudiante desarrollar√° los c√°lculos.
# En esta secci√≥n el estudiante desarrollar√° los c√°lculos.
#hass_dolar$predicciones <- predict(mod1)
hass_dolar <- hass_dolar %>%
mutate(predicciones = predict(mod1))
hass_dolar %>%
ggplot(aes(x = promedio_dolar, y = promedio_aguacate_kg)) +
geom_smooth(method = "lm", se = FALSE, color="lightblue") +
geom_segment(aes(xend=promedio_dolar, yend=predicciones),
col='red', lty='dashed') +
geom_point() +
geom_point(aes(y=predicciones), col='red') +
theme_light()
#Con R Base
# ggplot(datos, aes(x=Edad, y=Resistencia)) +
#   geom_smooth(method="lm", se=FALSE, color="lightgrey") +
#   geom_segment(aes(xend=Edad, yend=predicciones), col='red', lty='dashed') +
#   geom_point() +
#   geom_point(aes(y=predicciones), col='red') +
#   theme_light()
bo = 2
b1_1 = 3
b1_2 = 0.5
x <- seq(1,10)
# Estructura para el valor esperado de y dado x ()
# Esta estructura admitir√≠a otras formas funcionales
# El valor esperado es deterministico.
E_y_x_1 <- bo + b1_1 * x
E_y_x_2 <- bo + b1_1 * x + b1_2 * x^2
# el valor observado o valor real, es aleatorio.
y_obs_1 <- E_y_x_1 + rnorm(10, 0, 4)
y_obs_2 <- E_y_x_2 + rnorm(10, 0, 4)
datos_simulados <- data.frame(
x = x,
x_2 = x^2,
E_y_x_1 = E_y_x_1,
E_y_x_2 = E_y_x_2,
y_obs_1 = y_obs_1,
y_obs_2 = y_obs_2,
y_pred_1 = predict(lm(y_obs_1 ~ x)),
y_pred_2 = predict(lm(y_obs_2 ~ x+ x^2)))
datos_simulados %>%
ggplot(aes(x = x, y = y_obs_1)) +
geom_smooth(method = "lm", formula = y~x, se = FALSE, color="lightblue") +
geom_point(col = "green")+
geom_point(aes(y=y_obs_2), col='red')+
geom_smooth(method="lm", se= FALSE ,formula=y_obs_2~poly(x, 2),color = "blue")+
ylab("Y")
# Se define una semilla para generar los aleatorios.
set.seed(77)
alpha <- 0.7
E_y_x_3 = bo + alpha * (x + x^2)
y_obs_3 = E_y_x_3 + rnorm(10, 0, 4)
x_auxiliar = x + x^2
datos_simulados_2 <- data.frame(
x = x,
x_2 = x^2,
x_auxiliar = x_auxiliar,
E_y_x_3 = E_y_x_3,
y_obs_3 =  y_obs_3,
y_pred_3_1 = predict(lm(y_obs_3 ~ poly(x, 2))),
y_pred_3_2 = predict(lm(y_obs_3 ~ x_auxiliar )))
modelo1a <-  lm(y_obs_3 ~ poly(x, 2))
modelo1b <-  lm(y_obs_3 ~ poly(x, 2, raw = TRUE))
modelo2 <-  lm(y_obs_3 ~ x_auxiliar )
summary(modelo1a)
summary(modelo1b)
summary(modelo2)
datos_simulados_2 %>%
ggplot(aes(x = x , y = y_obs_3))+
geom_point(col = 'green')+
geom_point(aes(y = y_pred_3_1), col = 'blue')+
geom_point(aes(y = y_pred_3_2), col = 'red')
u1 = 1/sqrt(2)
u2 = sqrt(3/2) * (5-1)
u3 = sqrt(5/2) * ((3/2)*(5^2) - 3*5 + 1)
#E_y_5 = coef1 * u1 + coef2*u2 + coef3*u3
E_y_5 = modelo1a$coefficients[1] * u1 + modelo1a$coefficients[2]*u2 + modelo1a$coefficients[3]*u3
E_y_5
modelo1a$coefficients[1]
modelo1a$coefficients[2]
modelo1a$coefficients[3]
modelo1a
modelo1a
summary(modelo1a)
modelo1a <-  lm(y_obs_3 ~ poly(x, 2))
View(modelo1a)
modelo1a[["terms"]]
View(modelo1a)
modelo1a[["call"]]
View(modelo1b)
